# generated by datamodel-codegen:
#   filename:  <stdin>
#   timestamp: 2022-08-14T13:21:22+00:00

"""
Can be generated with the help of datamodel_code_generator like so:

# Execute ffprobe on the 5 first video to produce their json output
# concatenate them inside a json array with a root element,
# and generate their pydantic models
raw_json_output = [
    get_stream_info_with_ffprobe(path)
    for path in [*video_file_paths, ...]
]

raw_ffprobe_json = f'{{"videos": [{",".join(raw_json_output)}]}}'
datamodel_code_generator.generate(
    raw_ffprobe_json,
    input_file_type=datamodel_code_generator.InputFileType.Json,
    output=Path(".") / "ffprobe.py",
    target_python_version=datamodel_code_generator.PythonVersion.PY_310,
    class_name="VideosRoot"
)
"""

from __future__ import annotations

from typing import List, Optional

from pydantic import BaseModel


class Disposition(BaseModel):
    default: int
    dub: int
    original: int
    comment: int
    lyrics: int
    karaoke: int
    forced: int
    hearing_impaired: int
    visual_impaired: int
    clean_effects: int
    attached_pic: int
    timed_thumbnails: int
    captions: int
    descriptions: int
    metadata: int
    dependent: int
    still_image: int


class Tags(BaseModel):
    creation_time: Optional[str]
    language: Optional[str]
    handler_name: str
    vendor_id: str
    encoder: str


class Stream(BaseModel):
    index: int
    codec_name: str
    codec_long_name: str
    profile: str
    codec_type: str
    codec_tag_string: str
    codec_tag: str
    width: int
    height: int
    coded_width: int
    coded_height: int
    closed_captions: int
    film_grain: int
    has_b_frames: int
    sample_aspect_ratio: str
    display_aspect_ratio: str
    pix_fmt: str
    level: int
    color_range: Optional[str]
    color_space: Optional[str]
    chroma_location: str
    field_order: str
    refs: int
    id: str
    r_frame_rate: str
    avg_frame_rate: str
    time_base: str
    start_pts: int
    start_time: str
    duration_ts: int
    duration: str
    bit_rate: str
    bits_per_raw_sample: str
    nb_frames: str
    disposition: Disposition
    tags: Tags

    @property
    def avg_fps(self) -> float:
        # expect a "X/1" notation, with X being the average fps
        avg_frame_rate = self.avg_frame_rate

        num, den = avg_frame_rate.split("/")

        return float(num) / float(den)


class Tags1(BaseModel):
    creation_time: Optional[str]
    premiere_version: Optional[str]
    major_brand: Optional[str]
    minor_version: Optional[str]
    compatible_brands: Optional[str]
    encoder: Optional[str]


class Format(BaseModel):
    filename: str
    nb_streams: int
    nb_programs: int
    format_name: str
    format_long_name: str
    start_time: Optional[float]
    duration: float
    size: str
    bit_rate: Optional[str]
    probe_score: int
    tags: Tags1


class FfprobeVideo(BaseModel):
    streams: List[Stream]
    format: Format
